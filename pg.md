### ПОВТОРЕНИЕ: RGB И HEX ЦВЕТА

```
RGB - способ определения цвета, хранящий в себе три значения:
R - количество красного (red)
G - количество зеленого (green)
B - количество голубого (blue)

Каждое из чисел R, G, B находится в диапазоне от 0 до 255 включительно.
```

**Давайте определим переменные, отвечающие за некоторые из цветов:**
```py
WHITE = (255, 255, 255) #все цвета на максимум, значит белый
RED = (255, 0, 0) #Красный цвет на максимум, остальные по нулям
GREEN = (0, 255, 0) #255 зеленого, остальных по нулям
BLUE = (0, 0, 255) 
GRAY = (217, 217, 217) #светлосерый
PUPLE = (128, 128, 255) #R = 128, G = 128, B = 255
```

**Так же цвет может хранить четвертое значение от 0 до 255, которое будет отвечать за непрозрачность этого цвета.**
```py
# 0 - полностью прозрачный
# 255 - непрозрачный

TEST_COLOR = (128, 128, 255, 100)
```

**Чтобы из HEX, т.е. шестнадцатеричного представления цвета получить RGB в PyGame есть функция Color:**
```py
PURPLE_HEX = "#8080FF"
PURPLE_RGB = pygame.Color(PURPLE_HEX) #посмотрите, какое значение хранится в PURPLE_RGB 
```

---
### МОДУЛИ PYGAME:
```
* draw 
* display
* font
* time
```

### PYGAME: НАЧАЛО
PyGame - библиотека, которая используется в gamedev (разработке игр). Она содержит в себе ряд модулей и функций, позволяющих рисовать примитивы, работать со спрайтами, управлять временем и звуком. Тем не менее это все еще библиотека, а не игровой движок, тк она не предоставляем функций, описывающих физику, и не дает возможности работать с камерами. 

Чтобы использовать все возможности PyGame необходимо написать две строчки, которые подключат в ваш проект весь функционал:
```py
import pygame
pygame.init()
```

Стоит отметить, что есть некоторые особенности работы в алгоритмике, которые скрывают некоторые нюансы разработки приложений. Например, если бы вы создавали приложение в редакторе кода (Visual Studio Code или др, подходящий для python), то ваше окно появилось бы поверх вашей среды разработки, а не где-то в левой части:

![картинка](../images/pygame_window.jpg)

**Подготовка к удобному программированию. Задаем желаемые цвета, размер окна и fps заранее. Принято такие значения сохранять в переменные с верхним регистром:**
```py
WIDTH = 360  # ширина игрового окна
HEIGHT = 480 # высота игрового окна
FPS = 30 # частота кадров в секунду

BACKGROUND = (54, 57, 64) #цвет фона
BACKGROUND_BLACK = (48, 49, 54) #темный вариант фона
BORDER_COLOR = (36, 34, 38) #цвет рамок
WHITE = (215, 216, 220) #цвет текста
PURPLE_WHITE = (128, 128, 255) #акцентный фиолетовый
PURPLE_BLACK = (69, 69, 154) #акцентный фиолетовый
RED = (233, 119, 109) #красный
```


Только что мы объявили переменные, но пока нигде их не используем. Далее мы создадим окно, объект, отвечающий за нормализацию fps и игровой цикл. 

В алгоритмике скорее всего значения WIDTH и HEIGHT не будут влиять на размеры окна, тем не менее прописать стоит. У себя же я сделаю размер окна 640х480 (как в старых играх), поменяв значения WIDTH и HEIGHT в коде выше.
```py
screen = pygame.display.set_mode((WIDTH, HEIGHT)) #установка размера окна, (WIDTH, HEIGHT) - тапл
clock = pygame.time.Clock() #для дальнейшей нормализации FPS
```

clock - объект, который будет отвечать за нормализацию частоты кадров. Фактически будет определять FPS. Нормализацию FPS мы будем делать в игровом цикле. Как и все остальные действия отрисовки. 
```py
while True: #бесконечный цикл (игровой)
    clock.tick(FPS) #нормализация
    screen.fill(BACKGROUND) #изменяем фон каждый кадр
    pygame.display.update() #отображаем все изменения на экране
```


Особенность работы в алгоритмике: окошко спокойно закрывается при нажатии красного квадрата, однако это сопоставимо с alt+f4 (принудительным закрытием приложения). Чтобы закрыть программу, нужно обработать событие нажатия крестика внутри игрового цикла, иначе окошко никогда не закроется. Делать этого в алгоритмике не нужно.
```py
loop = True

#игровой цикл
while loop:
    clock.tick(FPS)

    #работа с событиями
    for event in pygame.event.get():
        # проверить закрытие окна
        if event.type == pygame.QUIT:
            loop = False


    screen.fill(BACKGROUND)
    pygame.display.update()
```

---
### СОБЫТИЯ В PYGAME

```
QUIT - выход из игры (нажатие крестика)
KEYDOWN - клавиша опущена (нажата любая клавиша)
KEYUP - клавиша поднята (не нажата)
```
```py
#код чисто для демонстрации работы событий
for event in pygame.event.get():
    if event.type == pygame.KEYDOWN: #если нажата любая клавиша
        if event.key == pygame.K_g: #если нажата g
            #меняю значения переменных BACKGROUND и PURPLE_BLACK местами, чтобы поменялся цвет фона
            save_color = BACKGROUND;
            BACKGROUND = PURPLE_BLACK;
            PURPLE_BLACK = save_color;
```


*Нажимаю g, меняется цвет фона.*
Каждый кадр цвет фона устаналивается как BACKGROUND, однако при нажатии g значение BACKGROUND меняется.

![картинка](../images/pygameonkeyg.gif)

---
### РИСОВАШКИ В PYGAME.

**В pygame библиотеке есть модуль draw, который отвечает за отрисовку различных примитивов.**
```py
pygame.draw.rect(wn, (r, g, b), (x, y, width, height) ) #wn - окно, на котором рисуем
pygame.draw.rect(wn, (r, g, b), (x, y, width, height), border_size ) 
pygame.draw.line(wn, (r, g, b), (x_start, y_start), (x_endm, y_end), border_size)
```

**Так же есть модуль font, который отвечает за отображение текста на окне**
```py
#создаем объект, отвечающий за стартовые настройки шрифта
font1 = pygame.font.Font(None, 60)

#создаем объект, который будет хранить в себе текст и цвет будущей надписи
t = font1.render("cat", True, (0,0,0)) 

#рисуем нашу надпись в заданных координатах
wn.blit(t, (150, 150))
```
